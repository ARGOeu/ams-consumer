#!/usr/bin/env python

import sys, os, hashlib, time, syslog
import daemon
import daemon.pidlockfile
import argparse
import signal
import errno

import ipdb

#from ams_consumer.AmsConsumerConfig import AmsConsumerConfig

pid_dir = '/var/run/ams-consumer/'
log_file = '/tmp/fajla'


def doMainProgram(fh):
    #ams_config = AmsConsumerConfig(conf_file)
    #ams_config.parse()
    #print ams_config.getOption(ams_config.AMS, 'Token')
    while True:
        time.sleep(5)
        syslog.syslog("vrti se demon" )
        #fh.write(ams_config.getOption(ams_config.OUTPUT, ErrorFilename))


def startDaemon(context_daemon):
    if context_daemon.pidfile.is_locked and not context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()
        if pid:
            try:
                os.kill(int(pid), 0)
                return 1
            except OSError, e:
                # no such process
                if(e.errno == errno.ESRCH):
                    context_daemon.pidfile.break_lock()

    fh = open(log_file, 'a')
    fh.write("inicijalizacija\n")
    context_daemon.files_preserve = [fh]

    def handleSigUsr1(signum, frame):
        syslog.syslog("signal usr1 ufacen.." + fh.name + "--\n")
        fh.write("SIG1 uvacen\n")
        fh.flush()
       # return 0

    def handleSigTerm(signum, frame):
        syslog.syslog("signal TERM uvacen")
        context_daemon.terminate(signum, frame)

    context_daemon.signal_map = {
        signal.SIGUSR1: handleSigUsr1,
        signal.SIGTERM: handleSigTerm #'terminate'
    }

    with context_daemon:
        doMainProgram(fh)


def stopDaemon(context_daemon):
    if context_daemon.pidfile.is_locked():
        pid = context_daemon.pidfile.read_pid()
        try:
            os.kill(pid, signal.SIGTERM)
        except OSError, e:
            if(e.errno == errno.ESRCH):
                context_daemon.pidfile.break_lock()

    return 0


def statusDaemon(context_daemon):
    if context_daemon.pidfile.is_locked and not context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()
        if pid:
            try:
                os.kill(int(pid), 0)
                return 0
            except OSError, e:
                # no such process
                if(e.errno == errno.ESRCH):
                    return 3
    return 4


def calcPidName(config_file):
    #if not os.path.isfile(config_file):
    #    print "no sac fajl"
    #    raise SystemExit(2)
    try:
        fh = open(config_file, 'r')
    except IOError, e:
        print e.strerror + config_file
        raise SystemExit(2)
    hash_obj = hashlib.md5(fh.read())   #ipdb.set_trace()
    fh.close()
    pid_name = 'amsconsd_' + hash_obj.hexdigest()[0:8] + '.pid'

    return pid_name


def daemonize(args):
    if not os.path.isdir(pid_dir):
        os.makedirs(pid_dir)
    pid_fullname = pid_dir + calcPidName(args.config)

    context_daemon = daemon.DaemonContext()
    context_daemon.pidfile = daemon.pidlockfile.PIDLockFile(pid_fullname, threaded=False)

    if args.daemon == 'start':
        startDaemon(context_daemon)
    elif args.daemon == 'stop':
        ret = stopDaemon(context_daemon)
        raise SystemExit(ret)
    elif args.daemon == 'restart':
        stopDaemon(context_daemon)
        startDaemon(context_daemon)
    elif args.daemon == 'status':
        ret = statusDaemon(context_daemon)
        raise SystemExit(ret)

def main():
    parser = argparse.ArgumentParser(prog='ams-consumerd')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-n', dest='nofork', action='store_true',
                        help='do not fork into background')
    group.add_argument('-d', dest='daemon', type=str,
                       help='daemon arguments: start, stop, restart, status', metavar='')
    parser.add_argument('-c', dest='config', type=str, required=True, help='config file')
    args = parser.parse_args()

    if args.nofork:
        try:
            doMainProgram(args.config)
        except KeyboardInterrupt:
            raise SystemExit(1)

    elif args.daemon:
        daemonize(args)

if __name__ == "__main__":
    main()
