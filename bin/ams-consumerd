#!/usr/bin/env python

import sys, os, hashlib, time
import daemon
import daemon.pidlockfile
import argparse
import signal
import errno

import ipdb

from datetime import datetime
from ams_consumer.AmsConsumerConfig import AmsConsumerConfig
from ams_consumer.Logger import Logger
from ams_consumer.SharedSingleton import SharedSingleton
from argo_ams_library import ArgoMessagingService, AmsMessage, AmsException

PROG_NAME = 'ams-consumer'
TIMEOUT = 10
pid_dir = '/var/run/' + PROG_NAME + '/'
log_dir = '/var/log/' + PROG_NAME + '/'
#log_file = '/tmp/fajla'


def doMainProgram(messagesConsumed = 0):
    config = singleton.getConfig()
    log = singleton.getLog()
    ams = ArgoMessagingService(endpoint=config.getOption(AmsConsumerConfig.AMS, 'Host'),
                               token=config.getOption(AmsConsumerConfig.AMS, 'Token'),
                               project=config.getOption(AmsConsumerConfig.AMS, 'Project'))
    pullInterval = config.getOption(AmsConsumerConfig.AMS, 'PullIntervalSec')
    subscriptions = config.getOption(AmsConsumerConfig.AMS, 'Subscriptions')
    msgNum = config.getOption(AmsConsumerConfig.AMS, 'PullMsgs')
    singleton.setLastStatTime(datetime.now())
    ackIds = []

    while True:
        #for sub in subscriptions:
        for id, msg in ams.pull_sub(subscriptions, msgNum, True, timeout=TIMEOUT):
            ackIds.append(id)
            singleton.incrementMsgCount()
            log.info(msg.json())
        #syslog.syslog("vrti se demon" )
        #fh.write(ams_config.getOption(ams_config.OUTPUT, ErrorFilename))
        if ackIds:
            ams.ack_sub(subscriptions, ackIds, timeout=TIMEOUT)
            ackIds = []

       # ipdb.set_trace()

        time.sleep(pullInterval)

        log.info('Vrti se svakijeh 3 sec')

def startDaemon(context_daemon):
    if context_daemon.pidfile.is_locked and not context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()
        if pid:
            try:
                os.kill(int(pid), 0)
                return 1
            except OSError, e:
                # no such process
                if(e.errno == errno.ESRCH):
                    context_daemon.pidfile.break_lock()

    #fh = open(log_file, 'a')
    #fh.write("inicijalizacija\n")
    context_daemon.files_preserve = [singleton.getLog().fileloghandle]

    def handleSigUsr1(signum, frame):
        singleton.getLog().info('SIG USR1 caught.')
        #singleton.getLog().info('frejmovaca::' + str(frame.f_locals['ackIds']))

        singleton.getLog().info(singleton.getLastStatTime().strftime('Since %Y-%m-%d %H:%M:%S messages consumed: %i') %
                 singleton.getMsgConsumed())
        singleton.resetCounters()
        #syslog.syslog("signal usr1 ufacen.." + fh.name + "--\n")
        #fh.write("SIG1 uvacen\n")
        #fh.flush()
       # return 0

    def handleSigTerm(signum, frame):
        # check if all pulled messages are acknowledged
        frameVars = frame.f_locals
        if 'ackIds' in frameVars and frameVars['ackIds']:
            frameVars['ams'].ack_sub(frameVars['subscriptions'], frameVars['ackIds'], timeout=TIMEOUT )

        singleton.getLog().info(singleton.getLastStatTime().strftime('Since %Y-%m-%d %H:%M:%S messages consumed: %i') %
                 singleton.getMsgConsumed())
        singleton.getLog().info('SIG TERM caught.')
        context_daemon.terminate(signum, frame)

    context_daemon.signal_map = {
        signal.SIGUSR1: handleSigUsr1,
        signal.SIGTERM: handleSigTerm #'terminate'
    }

    with context_daemon:
        doMainProgram()


def stopDaemon(context_daemon):
    if context_daemon.pidfile.is_locked():
        pid = context_daemon.pidfile.read_pid()
        try:
            os.kill(pid, signal.SIGTERM)
        except OSError, e:
            if(e.errno == errno.ESRCH):
                context_daemon.pidfile.break_lock()

    return 0


def statusDaemon(context_daemon):
    if context_daemon.pidfile.is_locked and not context_daemon.pidfile.i_am_locking():
        pid = context_daemon.pidfile.read_pid()
        if pid:
            try:
                os.kill(int(pid), 0)
                return 0
            except OSError, e:
                # no such process
                if(e.errno == errno.ESRCH):
                    return 3
    return 4


def calcPidName(config_file):
    if not os.path.isfile(config_file):
        print "No such file", config_file
        raise SystemExit(2)

    hash_obj = hashlib.md5(config_file)   #ipdb.set_trace()
    pid_name = 'amsconsd_' + hash_obj.hexdigest()[0:8] + '.pid'

    return pid_name


def daemonize(args):
    if not os.path.isdir(pid_dir):
        os.makedirs(pid_dir)
    pid_fullname = pid_dir + calcPidName(args.config)

    context_daemon = daemon.DaemonContext()
    context_daemon.pidfile = daemon.pidlockfile.PIDLockFile(pid_fullname, threaded=False)

    if args.daemon == 'start':
        startDaemon(context_daemon)
    elif args.daemon == 'stop':
        ret = stopDaemon(context_daemon)
        raise SystemExit(ret)
    elif args.daemon == 'restart':
        stopDaemon(context_daemon)
        startDaemon(context_daemon)
    elif args.daemon == 'status':
        ret = statusDaemon(context_daemon)
        raise SystemExit(ret)

def main():
    parser = argparse.ArgumentParser(prog=PROG_NAME + 'd')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-n', dest='nofork', action='store_true',
                        help='do not fork into background')
    group.add_argument('-d', dest='daemon', type=str,
                       help='daemon arguments: start, stop, restart, status', metavar='')
    parser.add_argument('-c', dest='config', type=str, required=True, help='config file')
    args = parser.parse_args()

    ac_config = AmsConsumerConfig(args.config)
    ac_config.parse()
    log_name = ac_config.getOption(AmsConsumerConfig.GENERAL, 'LogName')

    logger = Logger(sys.argv[0], log_name, log_dir)

    global singleton
    singleton = SharedSingleton(ac_config, logger)

    if args.nofork:
        try:
            doMainProgram()
        except KeyboardInterrupt:
            raise SystemExit(1)

    elif args.daemon:
        daemonize(args)

if __name__ == "__main__":
    main()
